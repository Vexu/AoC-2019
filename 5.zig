fn getVal(arr: []i32, ip: *usize, argIndex: u8) i32 {
    const n: i32 = switch (argIndex) {
        1 => 100,
        2 => 1000,
        3 => 10000,
        else => unreachable,
    };
    const arg = arr[ip.* + argIndex];
    return if (@rem(@divTrunc(arr[ip.*], n), 10) == 0) arr[@intCast(usize, arg)] else arg;
}

fn op1(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    var res = @intCast(usize, arr[ip.* + 3]);
    arr[res] = val1 + val2;
    ip.* += 4;
}

fn op2(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    var res = @intCast(usize, arr[ip.* + 3]);
    arr[res] = val1 * val2;
    ip.* += 4;
}

const stdin = std.io.getStdIn();

fn op3(arr: []i32, ip: *usize) void {
    var addr = arr[ip.* + 1];
    var buf: [16]u8 = undefined;
    var read: usize = 0;
    while (true) {
        read += stdin.read(buf[read .. read + 1]) catch @panic("failed");
        if (buf[read - 1] == '\n' or read == 15)
            break;
    }
    arr[@intCast(usize, addr)] = std.fmt.parseInt(i32, buf[0 .. read - 1], 10) catch @panic("invalid");
    ip.* += 2;
}

fn op4(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    std.debug.warn("{}\n", val1);
    ip.* += 2;
}

fn op5(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    if (val1 != 0)
        ip.* = @intCast(usize, val2)
    else
        ip.* += 3;
}

fn op6(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    if (val1 == 0)
        ip.* = @intCast(usize, val2)
    else
        ip.* += 3;
}

fn op7(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    var res = @intCast(usize, arr[ip.* + 3]);
    if (val1 < val2)
        arr[res] = 1
    else
        arr[res] = 0;
    ip.* += 4;
}

fn op8(arr: []i32, ip: *usize) void {
    var val1 = getVal(arr, ip, 1);
    var val2 = getVal(arr, ip, 2);
    var res = @intCast(usize, arr[ip.* + 3]);
    if (val1 == val2)
        arr[res] = 1
    else
        arr[res] = 0;
    ip.* += 4;
}

fn run(arr: []i32) void {
    var ip: usize = 0;
    while (ip < arr.len) {
        switch (@rem(arr[ip], 100)) {
            1 => op1(arr, &ip),
            2 => op2(arr, &ip),
            3 => op3(arr, &ip),
            4 => op4(arr, &ip),
            5 => op5(arr, &ip),
            6 => op6(arr, &ip),
            7 => op7(arr, &ip),
            8 => op8(arr, &ip),
            99 => return,
            else => unreachable,
        }
    }
}

const std = @import("std");

fn puzzle() void {
    var arr = [_]i32{ 3, 225, 1, 225, 6, 6, 1100, 1, 238, 225, 104, 0, 1101, 90, 60, 224, 1001, 224, -150, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 7, 224, 1, 224, 223, 223, 1, 57, 83, 224, 1001, 224, -99, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 5, 224, 1, 223, 224, 223, 1102, 92, 88, 225, 101, 41, 187, 224, 1001, 224, -82, 224, 4, 224, 1002, 223, 8, 223, 101, 7, 224, 224, 1, 224, 223, 223, 1101, 7, 20, 225, 1101, 82, 64, 225, 1002, 183, 42, 224, 101, -1554, 224, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 1, 224, 1, 224, 223, 223, 1102, 70, 30, 224, 101, -2100, 224, 224, 4, 224, 102, 8, 223, 223, 101, 1, 224, 224, 1, 224, 223, 223, 2, 87, 214, 224, 1001, 224, -2460, 224, 4, 224, 1002, 223, 8, 223, 101, 7, 224, 224, 1, 223, 224, 223, 102, 36, 180, 224, 1001, 224, -1368, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 5, 224, 1, 223, 224, 223, 1102, 50, 38, 225, 1102, 37, 14, 225, 1101, 41, 20, 225, 1001, 217, 7, 224, 101, -25, 224, 224, 4, 224, 1002, 223, 8, 223, 101, 2, 224, 224, 1, 224, 223, 223, 1101, 7, 30, 225, 1102, 18, 16, 225, 4, 223, 99, 0, 0, 0, 677, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1105, 0, 99999, 1105, 227, 247, 1105, 1, 99999, 1005, 227, 99999, 1005, 0, 256, 1105, 1, 99999, 1106, 227, 99999, 1106, 0, 265, 1105, 1, 99999, 1006, 0, 99999, 1006, 227, 274, 1105, 1, 99999, 1105, 1, 280, 1105, 1, 99999, 1, 225, 225, 225, 1101, 294, 0, 0, 105, 1, 0, 1105, 1, 99999, 1106, 0, 300, 1105, 1, 99999, 1, 225, 225, 225, 1101, 314, 0, 0, 106, 0, 0, 1105, 1, 99999, 7, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 329, 101, 1, 223, 223, 1107, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 344, 1001, 223, 1, 223, 8, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 359, 101, 1, 223, 223, 107, 677, 677, 224, 1002, 223, 2, 223, 1006, 224, 374, 101, 1, 223, 223, 7, 677, 226, 224, 1002, 223, 2, 223, 1006, 224, 389, 101, 1, 223, 223, 108, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 404, 101, 1, 223, 223, 1108, 677, 226, 224, 102, 2, 223, 223, 1005, 224, 419, 101, 1, 223, 223, 8, 226, 677, 224, 102, 2, 223, 223, 1006, 224, 434, 1001, 223, 1, 223, 1008, 677, 677, 224, 1002, 223, 2, 223, 1005, 224, 449, 1001, 223, 1, 223, 1107, 226, 677, 224, 102, 2, 223, 223, 1006, 224, 464, 101, 1, 223, 223, 107, 226, 677, 224, 1002, 223, 2, 223, 1006, 224, 479, 1001, 223, 1, 223, 7, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 494, 1001, 223, 1, 223, 8, 677, 677, 224, 102, 2, 223, 223, 1006, 224, 509, 1001, 223, 1, 223, 1108, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 524, 1001, 223, 1, 223, 1108, 226, 677, 224, 1002, 223, 2, 223, 1005, 224, 539, 101, 1, 223, 223, 107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 554, 1001, 223, 1, 223, 1007, 226, 226, 224, 102, 2, 223, 223, 1005, 224, 569, 1001, 223, 1, 223, 1008, 226, 226, 224, 102, 2, 223, 223, 1005, 224, 584, 101, 1, 223, 223, 1007, 677, 677, 224, 1002, 223, 2, 223, 1005, 224, 599, 1001, 223, 1, 223, 108, 677, 677, 224, 1002, 223, 2, 223, 1006, 224, 614, 1001, 223, 1, 223, 1007, 226, 677, 224, 1002, 223, 2, 223, 1006, 224, 629, 101, 1, 223, 223, 1008, 677, 226, 224, 102, 2, 223, 223, 1005, 224, 644, 101, 1, 223, 223, 1107, 226, 226, 224, 1002, 223, 2, 223, 1005, 224, 659, 1001, 223, 1, 223, 108, 226, 226, 224, 1002, 223, 2, 223, 1005, 224, 674, 101, 1, 223, 223, 4, 223, 99, 226 };
    run(arr[0..]);
}

pub fn main() void {
    puzzle();
    puzzle();
}
